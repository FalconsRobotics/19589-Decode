import cv2
import numpy as np

# ===== HSV Ranges (tighter green, good starting point) =====
PURPLE_LOWER = np.array([115, 40, 40])
PURPLE_UPPER = np.array([170, 255, 255])

# Updated green â€” narrower and slightly brighter
# Replace your old GREEN_LOWER / GREEN_UPPER with this:
GREEN_LOWER = np.array([45, 60, 50])   # hue higher, require more saturation/value
GREEN_UPPER = np.array([85, 255, 255])

# ===== Detection Parameters =====
MIN_BALL_AREA = 150
MAX_BALL_AREA = 12000
CIRCULARITY_THRESHOLD = 0.62   # slightly stricter
SOLIDITY_THRESHOLD = 0.80      # reject very hollow / rectangular shapes
MEAN_G_DELTA = 18              # mean G must be >= R + delta and >= B + delta
MIN_MEAN_SAT = 70              # require some saturation inside contour
MIN_MEAN_VAL = 50              # avoid too-dark areas

def auto_gain_balance(image):
    b, g, r = cv2.split(image.astype(np.float32))
    avg_b, avg_g, avg_r = np.mean(b), np.mean(g), np.mean(r)
    avg_gray = (avg_b + avg_g + avg_r) / 3.0
    gain_b = np.clip(avg_gray / (avg_b + 1e-5), 0.7, 1.3)
    gain_g = np.clip(avg_gray / (avg_g + 1e-5), 0.7, 1.3)
    gain_r = np.clip(avg_gray / (avg_r + 1e-5), 0.7, 1.3)
    b = cv2.multiply(b, gain_b)
    g = cv2.multiply(g, gain_g)
    r = cv2.multiply(r, gain_r)
    corrected = cv2.merge([b, g, r])
    return np.clip(corrected, 0, 255).astype(np.uint8)

def safe_find_contours(mask):
    cd = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    return cd[-2] if cd is not None else []

def contour_mean_bgr(img, contour):
    mask = np.zeros(img.shape[:2], dtype=np.uint8)
    cv2.drawContours(mask, [contour], -1, 255, -1)
    mean = cv2.mean(img, mask=mask)  # returns (b,g,r,alpha)
    return mean[:3], mask  # (b,g,r), mask

def contour_solidity(contour):
    area = cv2.contourArea(contour)
    hull = cv2.convexHull(contour)
    hull_area = cv2.contourArea(hull)
    if hull_area <= 0:
        return 0.0
    return float(area) / float(hull_area)

def detect_balls(image):
    """Return list of (color_name, cx, cy, contour, (x,y,w,h), area)."""
    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
    balls = []

    # Purple detection (HSV primary)
    purple_mask = cv2.inRange(hsv, PURPLE_LOWER, PURPLE_UPPER)
    purple_mask = cv2.medianBlur(purple_mask, 5)
    purple_mask = cv2.dilate(purple_mask, None, iterations=2)
    purple_contours = safe_find_contours(purple_mask)

    for contour in purple_contours:
        area = cv2.contourArea(contour)
        if not (MIN_BALL_AREA < area < MAX_BALL_AREA):
            continue
        perimeter = cv2.arcLength(contour, True)
        if perimeter == 0:
            continue
        circularity = 4 * np.pi * area / (perimeter * perimeter)
        if circularity < CIRCULARITY_THRESHOLD:
            continue
        x, y, w, h = cv2.boundingRect(contour)
        cx, cy = x + w // 2, y + h // 2
        balls.append(("purple", int(cx), int(cy), contour, (int(x),int(y),int(w),int(h)), float(area)))

    # Green detection: first via HSV mask (strict), then verify by mean color & solidity
    green_mask = cv2.inRange(hsv, GREEN_LOWER, GREEN_UPPER)
    green_mask = cv2.medianBlur(green_mask, 5)
    green_mask = cv2.dilate(green_mask, None, iterations=2)
    green_contours = safe_find_contours(green_mask)

    for contour in green_contours:
        area = cv2.contourArea(contour)
        if not (MIN_BALL_AREA < area < MAX_BALL_AREA):
            continue
        perimeter = cv2.arcLength(contour, True)
        if perimeter == 0:
            continue
        circularity = 4 * np.pi * area / (perimeter * perimeter)
        if circularity < CIRCULARITY_THRESHOLD:
            continue

        # solidity check
        solidity = contour_solidity(contour)
        if solidity < SOLIDITY_THRESHOLD:
            continue

        # mean color inside contour
        (mean_b, mean_g, mean_r), mask_contour = contour_mean_bgr(image, contour)
        # compute mean HSV in region to ensure saturation / value
        mean_hsv = cv2.mean(hsv, mask=mask_contour)[:3]  # (h,s,v)

        # checks: G dominance, saturation, brightness
        if not (mean_g >= mean_r + MEAN_G_DELTA and mean_g >= mean_b + MEAN_G_DELTA):
            continue
        if not (mean_hsv[1] >= MIN_MEAN_SAT and mean_hsv[2] >= MIN_MEAN_VAL):
            continue

        x, y, w, h = cv2.boundingRect(contour)
        cx, cy = x + w // 2, y + h // 2
        balls.append(("green", int(cx), int(cy), contour, (int(x),int(y),int(w),int(h)), float(area)))

    return balls

def runPipeline(image, llrobot):
    # 1) Per-frame auto-gain to normalize channels
    normalized = auto_gain_balance(image)

    # 2) detect balls (purple via HSV; green via HSV + color/solidity checks)
    balls = detect_balls(normalized)

    # 3) If we didn't find green via HSV+checks, try geometric fallback:
    #    look for circular blobs in grayscale that are not already purple -> infer green
    if not any(b[0] == "green" for b in balls):
        gray = cv2.cvtColor(normalized, cv2.COLOR_BGR2GRAY)
        gray = cv2.GaussianBlur(gray, (7,7), 1.5)
        edges = cv2.Canny(gray, 40, 120)
        contours = safe_find_contours(edges)
        for contour in contours:
            area = cv2.contourArea(contour)
            if not (MIN_BALL_AREA < area < MAX_BALL_AREA):
                continue
            perimeter = cv2.arcLength(contour, True)
            if perimeter == 0:
                continue
            circularity = 4 * np.pi * area / (perimeter * perimeter)
            if circularity < 0.66:
                continue
            # bounding rect center
            x, y, w, h = cv2.boundingRect(contour)
            cx, cy = x + w//2, y + h//2
            # skip if overlap with any purple mask (we don't want to double-classify)
            hsv = cv2.cvtColor(normalized, cv2.COLOR_BGR2HSV)
            if cv2.inRange(hsv, PURPLE_LOWER, PURPLE_UPPER)[cy, cx] != 0:
                continue
            # mean color check (ensure not purely gray/white)
            (mean_b, mean_g, mean_r), mask_contour = contour_mean_bgr(normalized, contour)
            if not (mean_g >= mean_r + (MEAN_G_DELTA - 8) and mean_g >= mean_b + (MEAN_G_DELTA - 8)):
                continue
            solidity = contour_solidity(contour)
            if solidity < 0.75:
                continue
            # Passed fallback: infer green
            balls.append(("green", int(cx), int(cy), contour, (int(x),int(y),int(w),int(h)), float(area)))
            # limit inferred additions to avoid spamming; break if enough
            if sum(1 for b in balls if b[0]=="green") >= 2:
                break

    # prepare llpython and image annotation
    llpython = [0.0]*8
    annotated = normalized.copy()
    if not balls:
        cv2.putText(annotated, "No ball detected", (20,40), cv2.FONT_HERSHEY_SIMPLEX, 1, (0,0,255), 2)
        return [], annotated, llpython

    # sort by area and keep up to 2
    balls.sort(key=lambda b: b[5], reverse=True)
    for i, (color_name, cx, cy, contour, (x,y,w,h), area) in enumerate(balls[:2]):
        draw_color = (255,0,255) if color_name=="purple" else (0,255,0)
        cv2.rectangle(annotated, (x,y), (x+w, y+h), draw_color, 2)
        cv2.circle(annotated, (cx,cy), 4, draw_color, -1)
        cv2.putText(annotated, f"{color_name.capitalize()} Ball", (x, y-8), cv2.FONT_HERSHEY_SIMPLEX, 0.5, draw_color, 2)
        llpython[i*4 + 0] = 1.0 if color_name=="purple" else 2.0
        llpython[i*4 + 1] = float(cx)
        llpython[i*4 + 2] = float(cy)
        llpython[i*4 + 3] = float(area)

    # Limelight expects a single contour list (largest) or []
    largest_contour = balls[0][3].astype(int).tolist()
    return largest_contour, annotated, llpython

